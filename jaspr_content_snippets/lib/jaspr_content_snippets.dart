// @docimport 'package:jaspr_content/components/code_block.dart';
import 'package:jaspr/server.dart';
import 'package:jaspr_content/jaspr_content.dart';
import 'package:path/path.dart';

import 'jaspr_content_snippets.dart';

export 'src/highlight/highlighter.dart';
export 'src/highlight/token_type.dart';
export 'src/highlighted_excerpt.dart';
export 'src/excerpts/excerpt.dart';

export 'src/ui/container.dart';
export 'src/ui/highlight.dart';
export 'src/ui/span.dart';
export 'src/ui/options.dart';

/// A [CustomComponent] rendering snippets for `jaspr_content`-based sites.
///
/// By default, the component can be used with the `<Snippet />` tag in source
/// files, but this can be customized with the [pattern] parameter.
///
///  The [snippets] is a map of all pre-rendered code snippets, typically
/// generated by the `jaspr_content_snippets:combiner` builder - see the readme
/// of this package for details.
CustomComponent renderedSnippetComponent({
  required Map<String, Map<String, String>> snippets,
  Pattern pattern = 'Snippet',
}) {
  return CustomComponent(
    pattern: pattern,
    builder: (tag, attributes, _) {
      return _RenderedSnippet(attributes, snippets);
    },
  );
}

/// A drop-in replacement for [CodeBlock] parsing inline sources and rendering
/// them with a builtin highlighting engine.
///
/// This supports the `dart` (using `package:analyzer`), `sql`, `drift` (using
/// `package:sqlparser`) and `yaml` (using `package:yaml`) packages.
final class BetterCodeBlock implements CustomComponent {
  @override
  Component? create(Node node, NodesBuilder builder) {
    if (node
        case ElementNode(
              tag: 'Code' || 'CodeBlock',
              :final children,
              :final attributes,
            ) ||
            ElementNode(
              tag: 'pre',
              children: [
                ElementNode(tag: 'code', :final children, :final attributes),
              ],
            )) {
      var language = attributes['language'];
      if (language == null &&
          (attributes['class']?.startsWith('language-') ?? false)) {
        language = attributes['class']!.substring('language-'.length);
      }

      final source = children?.map((c) => c.innerText).join(' ') ?? '';
      final raw = HighlightBlock(
        source: source,
        language: language ?? 'unknown',
      );

      return CodeSnippetContainer(child: raw);
    }
    return null;
  }
}

final class _RenderedSnippet extends AsyncStatelessComponent {
  final Map<String, String> attributes;
  final Map<String, Map<String, String>> snippets;

  _RenderedSnippet(this.attributes, this.snippets);

  @override
  Future<Component> build(BuildContext context) async {
    final href = attributes['href'];
    final name = attributes['name'] ?? '(full)';
    if (href == null) {
      throw ArgumentError('Missing attribute href');
    }

    final path = url.relative(
      url.join(context.page.path, '$href.snippet.json'),
      from: '/',
    );
    final resolvedSnippets = snippets[path];
    if (resolvedSnippets == null) {
      throw ArgumentError('Snippets for $path not found');
    }

    final snippet = resolvedSnippets[name];
    if (snippet == null) {
      throw ArgumentError('Snippet $name in $path not found');
    }

    return CodeSnippetContainer(child: raw(snippet));
  }
}
